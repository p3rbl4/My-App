***Docker - это средство упаковки, доставки и запуска приложений***

**Docker Image** - это образ 
А контейнер это приложение запущенное на базе образа.
В файлах **Dockerfile** содержатся инструкции по созданию образа
1. `FROM` — задаёт базовый (родительский) образ.
2. `LABEL` — описывает метаданные. Например — сведения о том, кто создал и поддерживает образ.
3. `ENV` — устанавливает постоянные переменные среды.
4. `RUN` — выполняет команду и создаёт слой образа. Используется для установки в контейнер пакетов.
5. `COPY` — копирует в контейнер файлы и папки.
6. `ADD` — копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы.
7. `CMD` — описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция `CMD`.
8. `WORKDIR` — задаёт рабочую директорию для следующей инструкции.
9. `ARG` — задаёт переменные для передачи Docker во время сборки образа.
10. `ENTRYPOINT` — предоставляет команду с аргументами для вызова во время выполнения контейнера. Аргументы не переопределяются.
11. `EXPOSE` — указывает на необходимость открыть порт.
12. `VOLUME` — создаёт точку монтирования для работы с постоянным хранилищем.

*Командная строка Docker*

Синтаксис выглядит следующим образом
```bash
docker container my_command
```

Вот команды, которые могут быть подставлены туда, где мы использовали `my_command`:  
  
- `create` — создание контейнера из образа.
- `start` — запуск существующего контейнера.
- `run` — создание контейнера и его запуск.
- `ls` — вывод списка работающих контейнеров.
- `inspect` — вывод подробной информации о контейнере.
- `logs` — вывод логов.
- `stop` — остановка работающего контейнера с отправкой главному процессу контейнера сигнала `SIGTERM`, и, через некоторое время, `SIGKILL`.
- `kill` — остановка работающего контейнера с отправкой главному процессу контейнера сигнала `SIGKILL`.
- `rm` — удаление остановленного контейнера.

Посмотреть созданные контейнеры можно командой:
`docker ps -a`

Для управления образами используются команды, которые выглядят так:
```bash
docker image my_command
```

Вот некоторые из команд этой группы:  
  
- `build` — сборка образа.
- `push` — отправка образа в удалённый реестр.
- `ls` — вывод списка образов.
- `history` — вывод сведений о слоях образа.
- `inspect` — вывод подробной информации об образе, в том числе — сведений о слоях.
- `rm` — удаление образа.
- `pull` - выгрузка образа из удалённого реестра

*Использование команд на практике*

```bash
docker container run -i -t -p 1000:8000 --rm my_image
```

Для того чтобы получить возможность взаимодействия с контейнером через терминал нужно совместно использовать флаги `-i` и `-t`.  
Флаг `-p` представляет собой сокращение для `--port`. Порт — это интерфейс, благодаря которому контейнер взаимодействует с внешним миром. Конструкция `1000:8000` перенаправляет порт Docker `8000` на порт `1000` компьютера, на котором выполняется контейнер. Если в контейнере работает некое приложение, способное выводить что-то в браузер, то, для того, чтобы к нему обратиться, в нашем случае можно перейти в браузере по адресу `localhost:1000`.  
Флаг `--rm` автоматически удаляет контейнер после того, как его выполнение завершится.

```bash
docker container run -d my_image
```

Флаг `-d` — это сокращение для `--detach`. Эта команда запускает контейнер в фоновом режиме. Это позволяет использовать терминал, из которого запущен контейнер, для выполнения других команд во время работы контейнера.

```bash
docker image build -t my_repo/my_image:my_tag .
```

Флаг `-t` — это сокращение для `--tag`. Он указывает Docker на то, что создаваемому образу надо назначить предоставленный в команде тег. В данном случае это `my_tag`.  
Точка в конце команды указывает на то, что образ надо собрать с использованием файла Dockerfile, находящегося в текущей рабочей директории.

*Когда образ собран, его можно опубликовать в реестре образов, для этого сначала нужно залогиниться в Docker Hub*

```bash
docker login 
```

После входа в систему можно будет отправлять образы в реестр. Делается это так:
```bash
docker image push my_repo/my_image:my_tag
```

[[Kubernetes]] [[Linux]]